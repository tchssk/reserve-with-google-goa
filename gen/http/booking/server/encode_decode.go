// Code generated by goa v3.2.4, DO NOT EDIT.
//
// booking HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/tchssk/reserve-with-google-goa/design

package server

import (
	"context"
	"io"
	"net/http"

	booking "github.com/tchssk/reserve-with-google-goa/gen/booking"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeBatchAvailabilityLookupResponse returns an encoder for responses
// returned by the booking batch_availability_lookup endpoint.
func EncodeBatchAvailabilityLookupResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*booking.BatchAvailabilityLookupResponse)
		enc := encoder(ctx, w)
		body := NewBatchAvailabilityLookupResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeBatchAvailabilityLookupRequest returns a decoder for requests sent to
// the booking batch_availability_lookup endpoint.
func DecodeBatchAvailabilityLookupRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body BatchAvailabilityLookupRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateBatchAvailabilityLookupRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewBatchAvailabilityLookupPayload(&body)
		user, pass, ok := r.BasicAuth()
		if !ok {
			return nil, goa.MissingFieldError("Authorization", "header")
		}
		payload.Username = user
		payload.Password = pass

		return payload, nil
	}
}

// EncodeBatchAvailabilityLookupError returns an encoder for errors returned by
// the batch_availability_lookup booking endpoint.
func EncodeBatchAvailabilityLookupError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchAvailabilityLookupBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchAvailabilityLookupUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchAvailabilityLookupForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchAvailabilityLookupNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchAvailabilityLookupConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "too_many_requests":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchAvailabilityLookupTooManyRequestsResponseBody(res)
			}
			w.Header().Set("goa-error", "too_many_requests")
			w.WriteHeader(http.StatusTooManyRequests)
			return enc.Encode(body)
		case "client_closed_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchAvailabilityLookupClientClosedRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "client_closed_request")
			w.WriteHeader(499)
			return enc.Encode(body)
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchAvailabilityLookupInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_implemented":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchAvailabilityLookupNotImplementedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_implemented")
			w.WriteHeader(http.StatusNotImplemented)
			return enc.Encode(body)
		case "service_unavailable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchAvailabilityLookupServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", "service_unavailable")
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "gateway_timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchAvailabilityLookupGatewayTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "gateway_timeout")
			w.WriteHeader(http.StatusGatewayTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCheckAvailabilityResponse returns an encoder for responses returned by
// the booking check_availability endpoint.
func EncodeCheckAvailabilityResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*booking.CheckAvailabilityResponse)
		enc := encoder(ctx, w)
		body := NewCheckAvailabilityResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCheckAvailabilityRequest returns a decoder for requests sent to the
// booking check_availability endpoint.
func DecodeCheckAvailabilityRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body CheckAvailabilityRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCheckAvailabilityRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewCheckAvailabilityPayload(&body)
		user, pass, ok := r.BasicAuth()
		if !ok {
			return nil, goa.MissingFieldError("Authorization", "header")
		}
		payload.Username = user
		payload.Password = pass

		return payload, nil
	}
}

// EncodeCheckAvailabilityError returns an encoder for errors returned by the
// check_availability booking endpoint.
func EncodeCheckAvailabilityError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCheckAvailabilityBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCheckAvailabilityUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCheckAvailabilityForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCheckAvailabilityNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCheckAvailabilityConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "too_many_requests":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCheckAvailabilityTooManyRequestsResponseBody(res)
			}
			w.Header().Set("goa-error", "too_many_requests")
			w.WriteHeader(http.StatusTooManyRequests)
			return enc.Encode(body)
		case "client_closed_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCheckAvailabilityClientClosedRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "client_closed_request")
			w.WriteHeader(499)
			return enc.Encode(body)
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCheckAvailabilityInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_implemented":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCheckAvailabilityNotImplementedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_implemented")
			w.WriteHeader(http.StatusNotImplemented)
			return enc.Encode(body)
		case "service_unavailable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCheckAvailabilityServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", "service_unavailable")
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "gateway_timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCheckAvailabilityGatewayTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "gateway_timeout")
			w.WriteHeader(http.StatusGatewayTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateBookingResponse returns an encoder for responses returned by the
// booking create_booking endpoint.
func EncodeCreateBookingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*booking.CreateBookingResponse)
		enc := encoder(ctx, w)
		body := NewCreateBookingResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCreateBookingRequest returns a decoder for requests sent to the
// booking create_booking endpoint.
func DecodeCreateBookingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body CreateBookingRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateBookingRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewCreateBookingPayload(&body)
		user, pass, ok := r.BasicAuth()
		if !ok {
			return nil, goa.MissingFieldError("Authorization", "header")
		}
		payload.Username = user
		payload.Password = pass

		return payload, nil
	}
}

// EncodeCreateBookingError returns an encoder for errors returned by the
// create_booking booking endpoint.
func EncodeCreateBookingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateBookingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateBookingUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateBookingForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateBookingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateBookingConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "too_many_requests":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateBookingTooManyRequestsResponseBody(res)
			}
			w.Header().Set("goa-error", "too_many_requests")
			w.WriteHeader(http.StatusTooManyRequests)
			return enc.Encode(body)
		case "client_closed_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateBookingClientClosedRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "client_closed_request")
			w.WriteHeader(499)
			return enc.Encode(body)
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateBookingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_implemented":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateBookingNotImplementedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_implemented")
			w.WriteHeader(http.StatusNotImplemented)
			return enc.Encode(body)
		case "service_unavailable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateBookingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", "service_unavailable")
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "gateway_timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateBookingGatewayTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "gateway_timeout")
			w.WriteHeader(http.StatusGatewayTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateBookingResponse returns an encoder for responses returned by the
// booking update_booking endpoint.
func EncodeUpdateBookingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*booking.UpdateBookingResponse)
		enc := encoder(ctx, w)
		body := NewUpdateBookingResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateBookingRequest returns a decoder for requests sent to the
// booking update_booking endpoint.
func DecodeUpdateBookingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body UpdateBookingRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateBookingRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewUpdateBookingPayload(&body)
		user, pass, ok := r.BasicAuth()
		if !ok {
			return nil, goa.MissingFieldError("Authorization", "header")
		}
		payload.Username = user
		payload.Password = pass

		return payload, nil
	}
}

// EncodeUpdateBookingError returns an encoder for errors returned by the
// update_booking booking endpoint.
func EncodeUpdateBookingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateBookingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateBookingUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateBookingForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateBookingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateBookingConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "too_many_requests":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateBookingTooManyRequestsResponseBody(res)
			}
			w.Header().Set("goa-error", "too_many_requests")
			w.WriteHeader(http.StatusTooManyRequests)
			return enc.Encode(body)
		case "client_closed_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateBookingClientClosedRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "client_closed_request")
			w.WriteHeader(499)
			return enc.Encode(body)
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateBookingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_implemented":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateBookingNotImplementedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_implemented")
			w.WriteHeader(http.StatusNotImplemented)
			return enc.Encode(body)
		case "service_unavailable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateBookingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", "service_unavailable")
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "gateway_timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateBookingGatewayTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "gateway_timeout")
			w.WriteHeader(http.StatusGatewayTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetBookingStatusResponse returns an encoder for responses returned by
// the booking get_booking_status endpoint.
func EncodeGetBookingStatusResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*booking.GetBookingStatusResponse)
		enc := encoder(ctx, w)
		body := NewGetBookingStatusResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetBookingStatusRequest returns a decoder for requests sent to the
// booking get_booking_status endpoint.
func DecodeGetBookingStatusRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body GetBookingStatusRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateGetBookingStatusRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewGetBookingStatusPayload(&body)
		user, pass, ok := r.BasicAuth()
		if !ok {
			return nil, goa.MissingFieldError("Authorization", "header")
		}
		payload.Username = user
		payload.Password = pass

		return payload, nil
	}
}

// EncodeGetBookingStatusError returns an encoder for errors returned by the
// get_booking_status booking endpoint.
func EncodeGetBookingStatusError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBookingStatusBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBookingStatusUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBookingStatusForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBookingStatusNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBookingStatusConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "too_many_requests":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBookingStatusTooManyRequestsResponseBody(res)
			}
			w.Header().Set("goa-error", "too_many_requests")
			w.WriteHeader(http.StatusTooManyRequests)
			return enc.Encode(body)
		case "client_closed_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBookingStatusClientClosedRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "client_closed_request")
			w.WriteHeader(499)
			return enc.Encode(body)
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBookingStatusInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_implemented":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBookingStatusNotImplementedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_implemented")
			w.WriteHeader(http.StatusNotImplemented)
			return enc.Encode(body)
		case "service_unavailable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBookingStatusServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", "service_unavailable")
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "gateway_timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetBookingStatusGatewayTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "gateway_timeout")
			w.WriteHeader(http.StatusGatewayTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeListBookingsResponse returns an encoder for responses returned by the
// booking list_bookings endpoint.
func EncodeListBookingsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*booking.ListBookingsResponse)
		enc := encoder(ctx, w)
		body := NewListBookingsResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListBookingsRequest returns a decoder for requests sent to the booking
// list_bookings endpoint.
func DecodeListBookingsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body ListBookingsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateListBookingsRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewListBookingsPayload(&body)
		user, pass, ok := r.BasicAuth()
		if !ok {
			return nil, goa.MissingFieldError("Authorization", "header")
		}
		payload.Username = user
		payload.Password = pass

		return payload, nil
	}
}

// EncodeListBookingsError returns an encoder for errors returned by the
// list_bookings booking endpoint.
func EncodeListBookingsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListBookingsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListBookingsUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListBookingsForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListBookingsNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListBookingsConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "too_many_requests":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListBookingsTooManyRequestsResponseBody(res)
			}
			w.Header().Set("goa-error", "too_many_requests")
			w.WriteHeader(http.StatusTooManyRequests)
			return enc.Encode(body)
		case "client_closed_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListBookingsClientClosedRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "client_closed_request")
			w.WriteHeader(499)
			return enc.Encode(body)
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListBookingsInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_implemented":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListBookingsNotImplementedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_implemented")
			w.WriteHeader(http.StatusNotImplemented)
			return enc.Encode(body)
		case "service_unavailable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListBookingsServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", "service_unavailable")
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "gateway_timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewListBookingsGatewayTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "gateway_timeout")
			w.WriteHeader(http.StatusGatewayTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// unmarshalSlotTimeRequestBodyRequestBodyToBookingSlotTime builds a value of
// type *booking.SlotTime from a value of type *SlotTimeRequestBodyRequestBody.
func unmarshalSlotTimeRequestBodyRequestBodyToBookingSlotTime(v *SlotTimeRequestBodyRequestBody) *booking.SlotTime {
	res := &booking.SlotTime{
		ServiceID:        *v.ServiceID,
		StartSec:         *v.StartSec,
		DurationSec:      v.DurationSec,
		AvailabilityTag:  v.AvailabilityTag,
		ConfirmationMode: v.ConfirmationMode,
	}
	if v.ResourceIds != nil {
		res.ResourceIds = unmarshalResourceIdsRequestBodyRequestBodyToBookingResourceIds(v.ResourceIds)
	}

	return res
}

// unmarshalResourceIdsRequestBodyRequestBodyToBookingResourceIds builds a
// value of type *booking.ResourceIds from a value of type
// *ResourceIdsRequestBodyRequestBody.
func unmarshalResourceIdsRequestBodyRequestBodyToBookingResourceIds(v *ResourceIdsRequestBodyRequestBody) *booking.ResourceIds {
	if v == nil {
		return nil
	}
	res := &booking.ResourceIds{
		StaffID:   v.StaffID,
		RoomID:    v.RoomID,
		PartySize: v.PartySize,
	}

	return res
}

// marshalBookingSlotTimeAvailabilityToSlotTimeAvailabilityResponseBody builds
// a value of type *SlotTimeAvailabilityResponseBody from a value of type
// *booking.SlotTimeAvailability.
func marshalBookingSlotTimeAvailabilityToSlotTimeAvailabilityResponseBody(v *booking.SlotTimeAvailability) *SlotTimeAvailabilityResponseBody {
	res := &SlotTimeAvailabilityResponseBody{
		Available: v.Available,
	}
	if v.SlotTime != nil {
		res.SlotTime = marshalBookingSlotTimeToSlotTimeResponseBody(v.SlotTime)
	}

	return res
}

// marshalBookingSlotTimeToSlotTimeResponseBody builds a value of type
// *SlotTimeResponseBody from a value of type *booking.SlotTime.
func marshalBookingSlotTimeToSlotTimeResponseBody(v *booking.SlotTime) *SlotTimeResponseBody {
	res := &SlotTimeResponseBody{
		ServiceID:        v.ServiceID,
		StartSec:         v.StartSec,
		DurationSec:      v.DurationSec,
		AvailabilityTag:  v.AvailabilityTag,
		ConfirmationMode: v.ConfirmationMode,
	}
	if v.ResourceIds != nil {
		res.ResourceIds = marshalBookingResourceIdsToResourceIdsResponseBody(v.ResourceIds)
	}

	return res
}

// marshalBookingResourceIdsToResourceIdsResponseBody builds a value of type
// *ResourceIdsResponseBody from a value of type *booking.ResourceIds.
func marshalBookingResourceIdsToResourceIdsResponseBody(v *booking.ResourceIds) *ResourceIdsResponseBody {
	if v == nil {
		return nil
	}
	res := &ResourceIdsResponseBody{
		StaffID:   v.StaffID,
		RoomID:    v.RoomID,
		PartySize: v.PartySize,
	}

	return res
}

// unmarshalSlotRequestBodyRequestBodyToBookingSlot builds a value of type
// *booking.Slot from a value of type *SlotRequestBodyRequestBody.
func unmarshalSlotRequestBodyRequestBodyToBookingSlot(v *SlotRequestBodyRequestBody) *booking.Slot {
	res := &booking.Slot{
		MerchantID:       v.MerchantID,
		ServiceID:        v.ServiceID,
		StartSec:         v.StartSec,
		DurationSec:      v.DurationSec,
		AvailabilityTag:  v.AvailabilityTag,
		ConfirmationMode: v.ConfirmationMode,
	}
	if v.Resources != nil {
		res.Resources = unmarshalResourceIdsRequestBodyRequestBodyToBookingResourceIds(v.Resources)
	}

	return res
}

// marshalBookingSlotToSlotResponseBody builds a value of type
// *SlotResponseBody from a value of type *booking.Slot.
func marshalBookingSlotToSlotResponseBody(v *booking.Slot) *SlotResponseBody {
	res := &SlotResponseBody{
		MerchantID:       v.MerchantID,
		ServiceID:        v.ServiceID,
		StartSec:         v.StartSec,
		DurationSec:      v.DurationSec,
		AvailabilityTag:  v.AvailabilityTag,
		ConfirmationMode: v.ConfirmationMode,
	}
	if v.Resources != nil {
		res.Resources = marshalBookingResourceIdsToResourceIdsResponseBody(v.Resources)
	}

	return res
}

// marshalBookingAvailabilityUpdateToAvailabilityUpdateResponseBody builds a
// value of type *AvailabilityUpdateResponseBody from a value of type
// *booking.AvailabilityUpdate.
func marshalBookingAvailabilityUpdateToAvailabilityUpdateResponseBody(v *booking.AvailabilityUpdate) *AvailabilityUpdateResponseBody {
	if v == nil {
		return nil
	}
	res := &AvailabilityUpdateResponseBody{}
	if v.SlotAvailability != nil {
		res.SlotAvailability = make([]*SlotAvailabilityResponseBody, len(v.SlotAvailability))
		for i, val := range v.SlotAvailability {
			res.SlotAvailability[i] = marshalBookingSlotAvailabilityToSlotAvailabilityResponseBody(val)
		}
	}

	return res
}

// marshalBookingSlotAvailabilityToSlotAvailabilityResponseBody builds a value
// of type *SlotAvailabilityResponseBody from a value of type
// *booking.SlotAvailability.
func marshalBookingSlotAvailabilityToSlotAvailabilityResponseBody(v *booking.SlotAvailability) *SlotAvailabilityResponseBody {
	res := &SlotAvailabilityResponseBody{
		CountAvailable: v.CountAvailable,
	}
	if v.Slot != nil {
		res.Slot = marshalBookingSlotToSlotResponseBody(v.Slot)
	}

	return res
}

// unmarshalLeaseReferenceRequestBodyRequestBodyToBookingLeaseReference builds
// a value of type *booking.LeaseReference from a value of type
// *LeaseReferenceRequestBodyRequestBody.
func unmarshalLeaseReferenceRequestBodyRequestBodyToBookingLeaseReference(v *LeaseReferenceRequestBodyRequestBody) *booking.LeaseReference {
	if v == nil {
		return nil
	}
	res := &booking.LeaseReference{
		LeaseID: *v.LeaseID,
	}

	return res
}

// unmarshalUserInformationRequestBodyRequestBodyToBookingUserInformation
// builds a value of type *booking.UserInformation from a value of type
// *UserInformationRequestBodyRequestBody.
func unmarshalUserInformationRequestBodyRequestBodyToBookingUserInformation(v *UserInformationRequestBodyRequestBody) *booking.UserInformation {
	res := &booking.UserInformation{
		UserID:       *v.UserID,
		GivenName:    *v.GivenName,
		FamilyName:   *v.FamilyName,
		Telephone:    *v.Telephone,
		Email:        *v.Email,
		LanguageCode: v.LanguageCode,
	}
	if v.Address != nil {
		res.Address = unmarshalPostalAddressRequestBodyRequestBodyToBookingPostalAddress(v.Address)
	}

	return res
}

// unmarshalPostalAddressRequestBodyRequestBodyToBookingPostalAddress builds a
// value of type *booking.PostalAddress from a value of type
// *PostalAddressRequestBodyRequestBody.
func unmarshalPostalAddressRequestBodyRequestBodyToBookingPostalAddress(v *PostalAddressRequestBodyRequestBody) *booking.PostalAddress {
	if v == nil {
		return nil
	}
	res := &booking.PostalAddress{
		Country:       *v.Country,
		Locality:      *v.Locality,
		Region:        v.Region,
		PostalCode:    *v.PostalCode,
		StreetAddress: *v.StreetAddress,
	}

	return res
}

// unmarshalPaymentInformationRequestBodyRequestBodyToBookingPaymentInformation
// builds a value of type *booking.PaymentInformation from a value of type
// *PaymentInformationRequestBodyRequestBody.
func unmarshalPaymentInformationRequestBodyRequestBodyToBookingPaymentInformation(v *PaymentInformationRequestBodyRequestBody) *booking.PaymentInformation {
	if v == nil {
		return nil
	}
	res := &booking.PaymentInformation{
		PrepaymentStatus:     *v.PrepaymentStatus,
		PaymentTransactionID: v.PaymentTransactionID,
		PaymentProcessedBy:   *v.PaymentProcessedBy,
		PaymentOptionID:      v.PaymentOptionID,
		UserPaymentOptionID:  v.UserPaymentOptionID,
		FraudSignals:         v.FraudSignals,
		PaResponse:           v.PaResponse,
		MdMerchantData:       v.MdMerchantData,
	}
	res.Price = unmarshalPriceRequestBodyRequestBodyToBookingPrice(v.Price)
	if v.TaxAmount != nil {
		res.TaxAmount = unmarshalPriceRequestBodyRequestBodyToBookingPrice(v.TaxAmount)
	}
	if v.Fees != nil {
		res.Fees = unmarshalPriceRequestBodyRequestBodyToBookingPrice(v.Fees)
	}
	if v.FeesAndTaxes != nil {
		res.FeesAndTaxes = unmarshalPriceRequestBodyRequestBodyToBookingPrice(v.FeesAndTaxes)
	}
	if v.Deposit != nil {
		res.Deposit = unmarshalDepositRequestBodyRequestBodyToBookingDeposit(v.Deposit)
	}
	if v.NoShowFee != nil {
		res.NoShowFee = unmarshalNoShowFeeRequestBodyRequestBodyToBookingNoShowFee(v.NoShowFee)
	}

	return res
}

// unmarshalPriceRequestBodyRequestBodyToBookingPrice builds a value of type
// *booking.Price from a value of type *PriceRequestBodyRequestBody.
func unmarshalPriceRequestBodyRequestBodyToBookingPrice(v *PriceRequestBodyRequestBody) *booking.Price {
	res := &booking.Price{
		PriceMicros:      *v.PriceMicros,
		CurrencyCode:     *v.CurrencyCode,
		PricingOptionTag: v.PricingOptionTag,
	}

	return res
}

// unmarshalDepositRequestBodyRequestBodyToBookingDeposit builds a value of
// type *booking.Deposit from a value of type *DepositRequestBodyRequestBody.
func unmarshalDepositRequestBodyRequestBodyToBookingDeposit(v *DepositRequestBodyRequestBody) *booking.Deposit {
	if v == nil {
		return nil
	}
	res := &booking.Deposit{
		MinAdvanceCancellationSec: *v.MinAdvanceCancellationSec,
		DepositType:               *v.DepositType,
	}
	res.Deposit = unmarshalPriceRequestBodyRequestBodyToBookingPrice(v.Deposit)

	return res
}

// unmarshalNoShowFeeRequestBodyRequestBodyToBookingNoShowFee builds a value of
// type *booking.NoShowFee from a value of type
// *NoShowFeeRequestBodyRequestBody.
func unmarshalNoShowFeeRequestBodyRequestBodyToBookingNoShowFee(v *NoShowFeeRequestBodyRequestBody) *booking.NoShowFee {
	if v == nil {
		return nil
	}
	res := &booking.NoShowFee{
		FeeType: *v.FeeType,
	}
	res.Fee = unmarshalPriceRequestBodyRequestBodyToBookingPrice(v.Fee)

	return res
}

// unmarshalPaymentProcessingParametersRequestBodyRequestBodyToBookingPaymentProcessingParameters
// builds a value of type *booking.PaymentProcessingParameters from a value of
// type *PaymentProcessingParametersRequestBodyRequestBody.
func unmarshalPaymentProcessingParametersRequestBodyRequestBodyToBookingPaymentProcessingParameters(v *PaymentProcessingParametersRequestBodyRequestBody) *booking.PaymentProcessingParameters {
	if v == nil {
		return nil
	}
	res := &booking.PaymentProcessingParameters{
		Processor:                  *v.Processor,
		PaymentMethodToken:         v.PaymentMethodToken,
		UnparsedPaymentMethodToken: v.UnparsedPaymentMethodToken,
		Version:                    v.Version,
		PaymentProcessor:           *v.PaymentProcessor,
	}
	if v.TokenizationConfig != nil {
		res.TokenizationConfig = unmarshalTokenizationConfigRequestBodyRequestBodyToBookingTokenizationConfig(v.TokenizationConfig)
	}

	return res
}

// unmarshalTokenizationConfigRequestBodyRequestBodyToBookingTokenizationConfig
// builds a value of type *booking.TokenizationConfig from a value of type
// *TokenizationConfigRequestBodyRequestBody.
func unmarshalTokenizationConfigRequestBodyRequestBodyToBookingTokenizationConfig(v *TokenizationConfigRequestBodyRequestBody) *booking.TokenizationConfig {
	if v == nil {
		return nil
	}
	res := &booking.TokenizationConfig{
		BillingInformationFormat: *v.BillingInformationFormat,
		MerchantOfRecordName:     *v.MerchantOfRecordName,
		PaymentCountryCode:       *v.PaymentCountryCode,
	}
	res.TokenizationParameter = make(map[string]string, len(v.TokenizationParameter))
	for key, val := range v.TokenizationParameter {
		tk := key
		tv := val
		res.TokenizationParameter[tk] = tv
	}
	res.CardNetworkParameters = make([]*booking.CardNetworkParameters, len(v.CardNetworkParameters))
	for i, val := range v.CardNetworkParameters {
		res.CardNetworkParameters[i] = unmarshalCardNetworkParametersRequestBodyRequestBodyToBookingCardNetworkParameters(val)
	}
	res.AllowedAuthMethods = make([]string, len(v.AllowedAuthMethods))
	for i, val := range v.AllowedAuthMethods {
		res.AllowedAuthMethods[i] = val
	}

	return res
}

// unmarshalCardNetworkParametersRequestBodyRequestBodyToBookingCardNetworkParameters
// builds a value of type *booking.CardNetworkParameters from a value of type
// *CardNetworkParametersRequestBodyRequestBody.
func unmarshalCardNetworkParametersRequestBodyRequestBodyToBookingCardNetworkParameters(v *CardNetworkParametersRequestBodyRequestBody) *booking.CardNetworkParameters {
	res := &booking.CardNetworkParameters{
		CardNetwork:        *v.CardNetwork,
		AcquirerBin:        *v.AcquirerBin,
		AcquirerMerchantID: *v.AcquirerMerchantID,
	}

	return res
}

// marshalBookingBookingToBookingResponseBody builds a value of type
// *BookingResponseBody from a value of type *booking.Booking.
func marshalBookingBookingToBookingResponseBody(v *booking.Booking) *BookingResponseBody {
	res := &BookingResponseBody{
		BookingID: v.BookingID,
		Status:    v.Status,
	}
	if v.Slot != nil {
		res.Slot = marshalBookingSlotToSlotResponseBody(v.Slot)
	}
	if v.UserInformation != nil {
		res.UserInformation = marshalBookingUserInformationToUserInformationResponseBody(v.UserInformation)
	}
	if v.PaymentInformation != nil {
		res.PaymentInformation = marshalBookingPaymentInformationToPaymentInformationResponseBody(v.PaymentInformation)
	}
	if v.VirtualSessionInfo != nil {
		res.VirtualSessionInfo = marshalBookingVirtualSessionInfoToVirtualSessionInfoResponseBody(v.VirtualSessionInfo)
	}
	if v.OfferInfo != nil {
		res.OfferInfo = marshalBookingOfferInfoToOfferInfoResponseBody(v.OfferInfo)
	}

	return res
}

// marshalBookingUserInformationToUserInformationResponseBody builds a value of
// type *UserInformationResponseBody from a value of type
// *booking.UserInformation.
func marshalBookingUserInformationToUserInformationResponseBody(v *booking.UserInformation) *UserInformationResponseBody {
	if v == nil {
		return nil
	}
	res := &UserInformationResponseBody{
		UserID:       v.UserID,
		GivenName:    v.GivenName,
		FamilyName:   v.FamilyName,
		Telephone:    v.Telephone,
		Email:        v.Email,
		LanguageCode: v.LanguageCode,
	}
	if v.Address != nil {
		res.Address = marshalBookingPostalAddressToPostalAddressResponseBody(v.Address)
	}

	return res
}

// marshalBookingPostalAddressToPostalAddressResponseBody builds a value of
// type *PostalAddressResponseBody from a value of type *booking.PostalAddress.
func marshalBookingPostalAddressToPostalAddressResponseBody(v *booking.PostalAddress) *PostalAddressResponseBody {
	if v == nil {
		return nil
	}
	res := &PostalAddressResponseBody{
		Country:       v.Country,
		Locality:      v.Locality,
		Region:        v.Region,
		PostalCode:    v.PostalCode,
		StreetAddress: v.StreetAddress,
	}

	return res
}

// marshalBookingPaymentInformationToPaymentInformationResponseBody builds a
// value of type *PaymentInformationResponseBody from a value of type
// *booking.PaymentInformation.
func marshalBookingPaymentInformationToPaymentInformationResponseBody(v *booking.PaymentInformation) *PaymentInformationResponseBody {
	if v == nil {
		return nil
	}
	res := &PaymentInformationResponseBody{
		PrepaymentStatus:     v.PrepaymentStatus,
		PaymentTransactionID: v.PaymentTransactionID,
		PaymentProcessedBy:   v.PaymentProcessedBy,
		PaymentOptionID:      v.PaymentOptionID,
		UserPaymentOptionID:  v.UserPaymentOptionID,
		FraudSignals:         v.FraudSignals,
		PaResponse:           v.PaResponse,
		MdMerchantData:       v.MdMerchantData,
	}
	if v.Price != nil {
		res.Price = marshalBookingPriceToPriceResponseBody(v.Price)
	}
	if v.TaxAmount != nil {
		res.TaxAmount = marshalBookingPriceToPriceResponseBody(v.TaxAmount)
	}
	if v.Fees != nil {
		res.Fees = marshalBookingPriceToPriceResponseBody(v.Fees)
	}
	if v.FeesAndTaxes != nil {
		res.FeesAndTaxes = marshalBookingPriceToPriceResponseBody(v.FeesAndTaxes)
	}
	if v.Deposit != nil {
		res.Deposit = marshalBookingDepositToDepositResponseBody(v.Deposit)
	}
	if v.NoShowFee != nil {
		res.NoShowFee = marshalBookingNoShowFeeToNoShowFeeResponseBody(v.NoShowFee)
	}

	return res
}

// marshalBookingPriceToPriceResponseBody builds a value of type
// *PriceResponseBody from a value of type *booking.Price.
func marshalBookingPriceToPriceResponseBody(v *booking.Price) *PriceResponseBody {
	res := &PriceResponseBody{
		PriceMicros:      v.PriceMicros,
		CurrencyCode:     v.CurrencyCode,
		PricingOptionTag: v.PricingOptionTag,
	}

	return res
}

// marshalBookingDepositToDepositResponseBody builds a value of type
// *DepositResponseBody from a value of type *booking.Deposit.
func marshalBookingDepositToDepositResponseBody(v *booking.Deposit) *DepositResponseBody {
	if v == nil {
		return nil
	}
	res := &DepositResponseBody{
		MinAdvanceCancellationSec: v.MinAdvanceCancellationSec,
		DepositType:               v.DepositType,
	}
	if v.Deposit != nil {
		res.Deposit = marshalBookingPriceToPriceResponseBody(v.Deposit)
	}

	return res
}

// marshalBookingNoShowFeeToNoShowFeeResponseBody builds a value of type
// *NoShowFeeResponseBody from a value of type *booking.NoShowFee.
func marshalBookingNoShowFeeToNoShowFeeResponseBody(v *booking.NoShowFee) *NoShowFeeResponseBody {
	if v == nil {
		return nil
	}
	res := &NoShowFeeResponseBody{
		FeeType: v.FeeType,
	}
	if v.Fee != nil {
		res.Fee = marshalBookingPriceToPriceResponseBody(v.Fee)
	}

	return res
}

// marshalBookingVirtualSessionInfoToVirtualSessionInfoResponseBody builds a
// value of type *VirtualSessionInfoResponseBody from a value of type
// *booking.VirtualSessionInfo.
func marshalBookingVirtualSessionInfoToVirtualSessionInfoResponseBody(v *booking.VirtualSessionInfo) *VirtualSessionInfoResponseBody {
	if v == nil {
		return nil
	}
	res := &VirtualSessionInfoResponseBody{
		SessionURL: v.SessionURL,
		MeetingID:  v.MeetingID,
		Password:   v.Password,
	}

	return res
}

// marshalBookingOfferInfoToOfferInfoResponseBody builds a value of type
// *OfferInfoResponseBody from a value of type *booking.OfferInfo.
func marshalBookingOfferInfoToOfferInfoResponseBody(v *booking.OfferInfo) *OfferInfoResponseBody {
	if v == nil {
		return nil
	}
	res := &OfferInfoResponseBody{
		OfferID: v.OfferID,
	}

	return res
}

// marshalBookingUserPaymentOptionToUserPaymentOptionResponseBody builds a
// value of type *UserPaymentOptionResponseBody from a value of type
// *booking.UserPaymentOption.
func marshalBookingUserPaymentOptionToUserPaymentOptionResponseBody(v *booking.UserPaymentOption) *UserPaymentOptionResponseBody {
	if v == nil {
		return nil
	}
	res := &UserPaymentOptionResponseBody{
		UserPaymentOptionID: v.UserPaymentOptionID,
		ValidStartTimeSec:   v.ValidStartTimeSec,
		ValidEndTimeSec:     v.ValidEndTimeSec,
		Type:                v.Type,
		OriginalCount:       v.OriginalCount,
		CurrentCount:        v.CurrentCount,
		PaymentOptionID:     v.PaymentOptionID,
	}

	return res
}

// marshalBookingBookingFailureToBookingFailureResponseBody builds a value of
// type *BookingFailureResponseBody from a value of type
// *booking.BookingFailure.
func marshalBookingBookingFailureToBookingFailureResponseBody(v *booking.BookingFailure) *BookingFailureResponseBody {
	if v == nil {
		return nil
	}
	res := &BookingFailureResponseBody{
		Cause:            v.Cause,
		RejectedCardType: v.RejectedCardType,
		Description:      v.Description,
	}
	if v.PaymentFailure != nil {
		res.PaymentFailure = marshalBookingPaymentFailureInformationToPaymentFailureInformationResponseBody(v.PaymentFailure)
	}

	return res
}

// marshalBookingPaymentFailureInformationToPaymentFailureInformationResponseBody
// builds a value of type *PaymentFailureInformationResponseBody from a value
// of type *booking.PaymentFailureInformation.
func marshalBookingPaymentFailureInformationToPaymentFailureInformationResponseBody(v *booking.PaymentFailureInformation) *PaymentFailureInformationResponseBody {
	if v == nil {
		return nil
	}
	res := &PaymentFailureInformationResponseBody{}
	if v.Threeds1Parameters != nil {
		res.Threeds1Parameters = marshalBookingThreeDS1ParametersToThreeDS1ParametersResponseBody(v.Threeds1Parameters)
	}

	return res
}

// marshalBookingThreeDS1ParametersToThreeDS1ParametersResponseBody builds a
// value of type *ThreeDS1ParametersResponseBody from a value of type
// *booking.ThreeDS1Parameters.
func marshalBookingThreeDS1ParametersToThreeDS1ParametersResponseBody(v *booking.ThreeDS1Parameters) *ThreeDS1ParametersResponseBody {
	res := &ThreeDS1ParametersResponseBody{
		AcsURL:         v.AcsURL,
		PaReq:          v.PaReq,
		TransactionID:  v.TransactionID,
		MdMerchantData: v.MdMerchantData,
	}

	return res
}

// unmarshalBookingRequestBodyRequestBodyToBookingBooking builds a value of
// type *booking.Booking from a value of type *BookingRequestBodyRequestBody.
func unmarshalBookingRequestBodyRequestBodyToBookingBooking(v *BookingRequestBodyRequestBody) *booking.Booking {
	res := &booking.Booking{
		BookingID: *v.BookingID,
		Status:    v.Status,
	}
	if v.Slot != nil {
		res.Slot = unmarshalSlotRequestBodyRequestBodyToBookingSlot(v.Slot)
	}
	if v.UserInformation != nil {
		res.UserInformation = unmarshalUserInformationRequestBodyRequestBodyToBookingUserInformation(v.UserInformation)
	}
	if v.PaymentInformation != nil {
		res.PaymentInformation = unmarshalPaymentInformationRequestBodyRequestBodyToBookingPaymentInformation(v.PaymentInformation)
	}
	if v.VirtualSessionInfo != nil {
		res.VirtualSessionInfo = unmarshalVirtualSessionInfoRequestBodyRequestBodyToBookingVirtualSessionInfo(v.VirtualSessionInfo)
	}
	if v.OfferInfo != nil {
		res.OfferInfo = unmarshalOfferInfoRequestBodyRequestBodyToBookingOfferInfo(v.OfferInfo)
	}

	return res
}

// unmarshalVirtualSessionInfoRequestBodyRequestBodyToBookingVirtualSessionInfo
// builds a value of type *booking.VirtualSessionInfo from a value of type
// *VirtualSessionInfoRequestBodyRequestBody.
func unmarshalVirtualSessionInfoRequestBodyRequestBodyToBookingVirtualSessionInfo(v *VirtualSessionInfoRequestBodyRequestBody) *booking.VirtualSessionInfo {
	if v == nil {
		return nil
	}
	res := &booking.VirtualSessionInfo{
		SessionURL: v.SessionURL,
		MeetingID:  v.MeetingID,
		Password:   v.Password,
	}

	return res
}

// unmarshalOfferInfoRequestBodyRequestBodyToBookingOfferInfo builds a value of
// type *booking.OfferInfo from a value of type
// *OfferInfoRequestBodyRequestBody.
func unmarshalOfferInfoRequestBodyRequestBodyToBookingOfferInfo(v *OfferInfoRequestBodyRequestBody) *booking.OfferInfo {
	if v == nil {
		return nil
	}
	res := &booking.OfferInfo{
		OfferID: *v.OfferID,
	}

	return res
}
