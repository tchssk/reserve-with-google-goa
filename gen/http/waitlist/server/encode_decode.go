// Code generated by goa v3.2.4, DO NOT EDIT.
//
// waitlist HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/tchssk/reserve-with-google-goa/design

package server

import (
	"context"
	"io"
	"net/http"

	waitlist "github.com/tchssk/reserve-with-google-goa/gen/waitlist"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeBatchGetWaitEstimatesResponse returns an encoder for responses
// returned by the waitlist batch_get_wait_estimates endpoint.
func EncodeBatchGetWaitEstimatesResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*waitlist.BatchGetWaitEstimatesResponse)
		enc := encoder(ctx, w)
		body := NewBatchGetWaitEstimatesResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeBatchGetWaitEstimatesRequest returns a decoder for requests sent to
// the waitlist batch_get_wait_estimates endpoint.
func DecodeBatchGetWaitEstimatesRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body BatchGetWaitEstimatesRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateBatchGetWaitEstimatesRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewBatchGetWaitEstimatesPayload(&body)
		user, pass, ok := r.BasicAuth()
		if !ok {
			return nil, goa.MissingFieldError("Authorization", "header")
		}
		payload.Username = user
		payload.Password = pass

		return payload, nil
	}
}

// EncodeBatchGetWaitEstimatesError returns an encoder for errors returned by
// the batch_get_wait_estimates waitlist endpoint.
func EncodeBatchGetWaitEstimatesError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchGetWaitEstimatesBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchGetWaitEstimatesUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchGetWaitEstimatesForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchGetWaitEstimatesNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchGetWaitEstimatesConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "too_many_requests":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchGetWaitEstimatesTooManyRequestsResponseBody(res)
			}
			w.Header().Set("goa-error", "too_many_requests")
			w.WriteHeader(http.StatusTooManyRequests)
			return enc.Encode(body)
		case "client_closed_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchGetWaitEstimatesClientClosedRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "client_closed_request")
			w.WriteHeader(499)
			return enc.Encode(body)
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchGetWaitEstimatesInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_implemented":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchGetWaitEstimatesNotImplementedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_implemented")
			w.WriteHeader(http.StatusNotImplemented)
			return enc.Encode(body)
		case "service_unavailable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchGetWaitEstimatesServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", "service_unavailable")
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "gateway_timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewBatchGetWaitEstimatesGatewayTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "gateway_timeout")
			w.WriteHeader(http.StatusGatewayTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateWaitlistEntryResponse returns an encoder for responses returned
// by the waitlist create_waitlist_entry endpoint.
func EncodeCreateWaitlistEntryResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*waitlist.CreateWaitlistEntryResponse)
		enc := encoder(ctx, w)
		body := NewCreateWaitlistEntryResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCreateWaitlistEntryRequest returns a decoder for requests sent to the
// waitlist create_waitlist_entry endpoint.
func DecodeCreateWaitlistEntryRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body CreateWaitlistEntryRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateWaitlistEntryRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewCreateWaitlistEntryPayload(&body)
		user, pass, ok := r.BasicAuth()
		if !ok {
			return nil, goa.MissingFieldError("Authorization", "header")
		}
		payload.Username = user
		payload.Password = pass

		return payload, nil
	}
}

// EncodeCreateWaitlistEntryError returns an encoder for errors returned by the
// create_waitlist_entry waitlist endpoint.
func EncodeCreateWaitlistEntryError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateWaitlistEntryBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateWaitlistEntryUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateWaitlistEntryForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateWaitlistEntryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateWaitlistEntryConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "too_many_requests":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateWaitlistEntryTooManyRequestsResponseBody(res)
			}
			w.Header().Set("goa-error", "too_many_requests")
			w.WriteHeader(http.StatusTooManyRequests)
			return enc.Encode(body)
		case "client_closed_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateWaitlistEntryClientClosedRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "client_closed_request")
			w.WriteHeader(499)
			return enc.Encode(body)
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateWaitlistEntryInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_implemented":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateWaitlistEntryNotImplementedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_implemented")
			w.WriteHeader(http.StatusNotImplemented)
			return enc.Encode(body)
		case "service_unavailable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateWaitlistEntryServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", "service_unavailable")
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "gateway_timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCreateWaitlistEntryGatewayTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "gateway_timeout")
			w.WriteHeader(http.StatusGatewayTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetWaitlistEntryResponse returns an encoder for responses returned by
// the waitlist get_waitlist_entry endpoint.
func EncodeGetWaitlistEntryResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*waitlist.GetWaitlistEntryResponse)
		enc := encoder(ctx, w)
		body := NewGetWaitlistEntryResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetWaitlistEntryRequest returns a decoder for requests sent to the
// waitlist get_waitlist_entry endpoint.
func DecodeGetWaitlistEntryRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body GetWaitlistEntryRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateGetWaitlistEntryRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewGetWaitlistEntryPayload(&body)
		user, pass, ok := r.BasicAuth()
		if !ok {
			return nil, goa.MissingFieldError("Authorization", "header")
		}
		payload.Username = user
		payload.Password = pass

		return payload, nil
	}
}

// EncodeGetWaitlistEntryError returns an encoder for errors returned by the
// get_waitlist_entry waitlist endpoint.
func EncodeGetWaitlistEntryError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetWaitlistEntryBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetWaitlistEntryUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetWaitlistEntryForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetWaitlistEntryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetWaitlistEntryConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "too_many_requests":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetWaitlistEntryTooManyRequestsResponseBody(res)
			}
			w.Header().Set("goa-error", "too_many_requests")
			w.WriteHeader(http.StatusTooManyRequests)
			return enc.Encode(body)
		case "client_closed_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetWaitlistEntryClientClosedRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "client_closed_request")
			w.WriteHeader(499)
			return enc.Encode(body)
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetWaitlistEntryInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_implemented":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetWaitlistEntryNotImplementedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_implemented")
			w.WriteHeader(http.StatusNotImplemented)
			return enc.Encode(body)
		case "service_unavailable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetWaitlistEntryServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", "service_unavailable")
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "gateway_timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetWaitlistEntryGatewayTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "gateway_timeout")
			w.WriteHeader(http.StatusGatewayTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteWaitlistEntryResponse returns an encoder for responses returned
// by the waitlist delete_waitlist_entry endpoint.
func EncodeDeleteWaitlistEntryResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		w.WriteHeader(http.StatusOK)
		return nil
	}
}

// DecodeDeleteWaitlistEntryRequest returns a decoder for requests sent to the
// waitlist delete_waitlist_entry endpoint.
func DecodeDeleteWaitlistEntryRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body DeleteWaitlistEntryRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateDeleteWaitlistEntryRequestBody(&body)
		if err != nil {
			return nil, err
		}
		payload := NewDeleteWaitlistEntryPayload(&body)
		user, pass, ok := r.BasicAuth()
		if !ok {
			return nil, goa.MissingFieldError("Authorization", "header")
		}
		payload.Username = user
		payload.Password = pass

		return payload, nil
	}
}

// EncodeDeleteWaitlistEntryError returns an encoder for errors returned by the
// delete_waitlist_entry waitlist endpoint.
func EncodeDeleteWaitlistEntryError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteWaitlistEntryBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteWaitlistEntryUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "forbidden":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteWaitlistEntryForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "not_found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteWaitlistEntryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not_found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "conflict":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteWaitlistEntryConflictResponseBody(res)
			}
			w.Header().Set("goa-error", "conflict")
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "too_many_requests":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteWaitlistEntryTooManyRequestsResponseBody(res)
			}
			w.Header().Set("goa-error", "too_many_requests")
			w.WriteHeader(http.StatusTooManyRequests)
			return enc.Encode(body)
		case "client_closed_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteWaitlistEntryClientClosedRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "client_closed_request")
			w.WriteHeader(499)
			return enc.Encode(body)
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteWaitlistEntryInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "not_implemented":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteWaitlistEntryNotImplementedResponseBody(res)
			}
			w.Header().Set("goa-error", "not_implemented")
			w.WriteHeader(http.StatusNotImplemented)
			return enc.Encode(body)
		case "service_unavailable":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteWaitlistEntryServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", "service_unavailable")
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "gateway_timeout":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewDeleteWaitlistEntryGatewayTimeoutResponseBody(res)
			}
			w.Header().Set("goa-error", "gateway_timeout")
			w.WriteHeader(http.StatusGatewayTimeout)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalWaitlistWaitEstimateToWaitEstimateResponseBody builds a value of type
// *WaitEstimateResponseBody from a value of type *waitlist.WaitEstimate.
func marshalWaitlistWaitEstimateToWaitEstimateResponseBody(v *waitlist.WaitEstimate) *WaitEstimateResponseBody {
	if v == nil {
		return nil
	}
	res := &WaitEstimateResponseBody{
		PartySize:                v.PartySize,
		WaitlistConfirmationMode: v.WaitlistConfirmationMode,
	}
	if v.WaitLength != nil {
		res.WaitLength = marshalWaitlistWaitLengthToWaitLengthResponseBody(v.WaitLength)
	}

	return res
}

// marshalWaitlistWaitLengthToWaitLengthResponseBody builds a value of type
// *WaitLengthResponseBody from a value of type *waitlist.WaitLength.
func marshalWaitlistWaitLengthToWaitLengthResponseBody(v *waitlist.WaitLength) *WaitLengthResponseBody {
	if v == nil {
		return nil
	}
	res := &WaitLengthResponseBody{
		PartiesAheadCount: v.PartiesAheadCount,
	}
	if v.EstimatedSeatTimeRange != nil {
		res.EstimatedSeatTimeRange = marshalWaitlistEstimatedSeatTimeRangeToEstimatedSeatTimeRangeResponseBody(v.EstimatedSeatTimeRange)
	}

	return res
}

// marshalWaitlistEstimatedSeatTimeRangeToEstimatedSeatTimeRangeResponseBody
// builds a value of type *EstimatedSeatTimeRangeResponseBody from a value of
// type *waitlist.EstimatedSeatTimeRange.
func marshalWaitlistEstimatedSeatTimeRangeToEstimatedSeatTimeRangeResponseBody(v *waitlist.EstimatedSeatTimeRange) *EstimatedSeatTimeRangeResponseBody {
	res := &EstimatedSeatTimeRangeResponseBody{
		StartSeconds: v.StartSeconds,
		EndSeconds:   v.EndSeconds,
	}

	return res
}

// unmarshalUserInformationRequestBodyRequestBodyToWaitlistUserInformation
// builds a value of type *waitlist.UserInformation from a value of type
// *UserInformationRequestBodyRequestBody.
func unmarshalUserInformationRequestBodyRequestBodyToWaitlistUserInformation(v *UserInformationRequestBodyRequestBody) *waitlist.UserInformation {
	res := &waitlist.UserInformation{
		UserID:       *v.UserID,
		GivenName:    *v.GivenName,
		FamilyName:   *v.FamilyName,
		Telephone:    *v.Telephone,
		Email:        *v.Email,
		LanguageCode: v.LanguageCode,
	}
	if v.Address != nil {
		res.Address = unmarshalPostalAddressRequestBodyRequestBodyToWaitlistPostalAddress(v.Address)
	}

	return res
}

// unmarshalPostalAddressRequestBodyRequestBodyToWaitlistPostalAddress builds a
// value of type *waitlist.PostalAddress from a value of type
// *PostalAddressRequestBodyRequestBody.
func unmarshalPostalAddressRequestBodyRequestBodyToWaitlistPostalAddress(v *PostalAddressRequestBodyRequestBody) *waitlist.PostalAddress {
	if v == nil {
		return nil
	}
	res := &waitlist.PostalAddress{
		Country:       *v.Country,
		Locality:      *v.Locality,
		Region:        v.Region,
		PostalCode:    *v.PostalCode,
		StreetAddress: *v.StreetAddress,
	}

	return res
}

// marshalWaitlistWaitlistBusinessLogicFailureToWaitlistBusinessLogicFailureResponseBody
// builds a value of type *WaitlistBusinessLogicFailureResponseBody from a
// value of type *waitlist.WaitlistBusinessLogicFailure.
func marshalWaitlistWaitlistBusinessLogicFailureToWaitlistBusinessLogicFailureResponseBody(v *waitlist.WaitlistBusinessLogicFailure) *WaitlistBusinessLogicFailureResponseBody {
	if v == nil {
		return nil
	}
	res := &WaitlistBusinessLogicFailureResponseBody{
		Cause:       v.Cause,
		Description: v.Description,
	}

	return res
}

// marshalWaitlistWaitlistEntryToWaitlistEntryResponseBody builds a value of
// type *WaitlistEntryResponseBody from a value of type *waitlist.WaitlistEntry.
func marshalWaitlistWaitlistEntryToWaitlistEntryResponseBody(v *waitlist.WaitlistEntry) *WaitlistEntryResponseBody {
	res := &WaitlistEntryResponseBody{
		WaitlistEntryState: v.WaitlistEntryState,
	}
	if v.WaitlistEntryStateTimes != nil {
		res.WaitlistEntryStateTimes = marshalWaitlistWaitlistEntryStateTimesToWaitlistEntryStateTimesResponseBody(v.WaitlistEntryStateTimes)
	}
	if v.WaitEstimate != nil {
		res.WaitEstimate = marshalWaitlistWaitEstimateToWaitEstimateResponseBody(v.WaitEstimate)
	}

	return res
}

// marshalWaitlistWaitlistEntryStateTimesToWaitlistEntryStateTimesResponseBody
// builds a value of type *WaitlistEntryStateTimesResponseBody from a value of
// type *waitlist.WaitlistEntryStateTimes.
func marshalWaitlistWaitlistEntryStateTimesToWaitlistEntryStateTimesResponseBody(v *waitlist.WaitlistEntryStateTimes) *WaitlistEntryStateTimesResponseBody {
	res := &WaitlistEntryStateTimesResponseBody{
		CreatedTimeSeconds:        v.CreatedTimeSeconds,
		CanceledTimeSeconds:       v.CanceledTimeSeconds,
		ServiceReadiedTimeSeconds: v.ServiceReadiedTimeSeconds,
		CheckedInTimeSeconds:      v.CheckedInTimeSeconds,
		SeatedTimeSeconds:         v.SeatedTimeSeconds,
		MarkedNoShowTimeSeconds:   v.MarkedNoShowTimeSeconds,
	}

	return res
}
